x=1
def f(): #声明
    x=3
    g()
    print("f:",x) # 3
 
def g(): #声明
    print("g:",x) # 1
f()
print("main:",x) # 1
# 对于python的这段代码来说，这里有两个值得注意的地方：
# 调用函数之前，理论上要先定义好函数，但这里g()的调用似乎看上去比g()的定义更先
# f()中调用g()时，为什么g()输出的是1而不是3
# 第一个问题在前文已经解释过了，再解释一遍：虽然f()里面有g()的调用语句，但def f()只是声明，但在调用f()之前，是不会去调用g()的。所以，只要f()的调用语句在def g()之后，就是正确的。
# 第二个问题，python是词法作用域，所以：
# (1).首先声明def f()，在此期间会创建一个本地变量x，并且print("f:",x)中的x指向这个本地变量；
# (2).然后声明g()，在此期间，g()的定义语句不在f()内部，而是在全局范围，所以它看见的是x是全局x，所以print("g:",x)中的x指向全局变量x；
# 当调用f()的时候，执行到g()时，g()中所指向的是全局范围的x，而非f()段中的x。所以，输出1。
# 再看一个嵌套在函数内部的示例：

x=3
def f1():
    x=4
    def f2():
        print(x)
    x=5
    f2()
f1() # 输出5
# 其实也很容易理解，因为def f2()是定义在f1()内部的，所以f2()看见的x是f1()中的x，也就是说print(x)中的x指向的是f1()中的x。但在调用f2()之前，重新赋值了x=5，等到调用f2()的时候，根据x的指向，将找到新的x的值。也就是说，前面的示例中，有两个独立的变量x：全局的和f()本地的。后面这个示例中只有一个变量x，属于f()。